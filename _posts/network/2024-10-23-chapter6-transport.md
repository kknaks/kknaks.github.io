---
title:  6장 전송 계층, 오류업이 데이터를 전달하는 단계
date: 2024-10-23 1:35:23 +0900
category: [network]
tags: network, sc기초
permalink: /blog/network06/
---

# 전송계층의 역할
- **전송계층의 역할**
  - 오류를 점검하는 기능(혼잡제어, 흐름제어, 오류제어 )
  - 제대로 수신했을 때 어떤 어플리케이션에 전달해야 하는지 식별

## 1. 혼잡제어
- **혼잡제어** : 네트워크로 들어가는 정보량을 조절하여 네크워크가 혼잡해지지 않게 조절 하는 방법
  - 먼저 하나의 데이터만 보내고 수신자에서 ACK가 오면 전송량을 2배증가
  - 타임아웃이 발생하면 여러개 보냈던 데이터를 줄여서 전송
  - 동일한 ACK가 여러번 오면 데이터를 줄여서 전송
  - 이후 정상적인 ACK가 돌아오면 데이터 전송량을 배수로 늘려서 전송

## 2. 흐름제어 
- **흐름제어** 데이터 링크계층의 흐름제어(정지-대기)방식과 동일하게 ACK가 도달하면 데이터를 송신  

## 3. 오류제어 
- **오류제어** : 확인응담과 시간초과 방법을 사용하여 오류성을 검증
  - 확인응답 : 수신자 측으로 부터 ACK라는 응답을 받지 못하면 오류로 판단
  - 시간초과 : 특정 시간내에 ACK가 없으면 세그먼트에 오류가 있다고 판단
- 데이터 재전송
  - 데이터가 중간에 손실 될 때 : 수신자가 데이터를 받지 못하는 경우
  - 데이터의 순서가 바뀌었을 때 : 수신자가 받은 데이터를 순번과 송신자의 데이터의 순번이 다를경우
  - 데이터가 훼손 되었을 때 : 수신자가 받은 데이터의 일부 누락이 발생할 경우 

# 3방향 핸드셰이크 
- 전송계층의 목적은 데이터를 문제없이 송신하는 것을 목표로 한다. 
  - 연결형 통신 : 데이터를 정확하게 전달하는 것을 목표로, TCP프로토콜을 사용
  - 비연결형 통신 : 데이터를 효율적으로 전달하는 것을 목표로, UDP프로토콜을 사용한다. 

## 1. TCP 통신
- **3방향 핸드셰이크** : 장비간에 서로 통신할 준비가 되었는지 확인 하는 과정
- 수신자와 송신자가 양쪽 모두 데이터를 전송할 준비 완료 되었음을 의미 
![image](https://github.com/user-attachments/assets/a9294fdb-782a-49ef-b217-020268bf24d7)
  > 3 Way Handshake 과정<br>
  > 1. 송신자가 연결 요청을 위해 SYN(Synchronize Sequece Number)임의의 숫자를 보낸다. => ...."적이요?"
  > 2. 수신자는 송신자에 받은 SYN에 1을 더해 ACK를 만들고, 수신자도 SYN 임임의 숫자를 보낸다. => "네"(ACK), 님은요?(new SYN)"
  > 3. 송신자는 수신자가 보낸 SYN에 1을 더해 ACK를 다시 보낸다. => "OKOK(ACK)"

# TCP의 구조 

## 1. TCP헤더 구조 
- 전송계층의 헤더 구조는 다음과 같다

![image](https://github.com/user-attachments/assets/4ee887bb-6705-4d71-a52a-d4972936a7dc)

## 2. 포트번호 
- **포트번호** : 수신자의 어플리케이션 주소
- 전송계층의 역할은 수신자의 **어플리케이션과 통신**하는 지를 정의 하는 곳이다. 
- **어플리케이션의 주소**가 포트번호이며, 총 65,536개가 존재한다.
  - 0 - 1023번 : well-known port로 특정한 쓰임을 위해 사용되는 포트번호이다. 
        
    | 포트  | 프로토콜   | 용도                   |
    |-----|--------|----------------------|
    | 20  | FTP    | FTP로 데이터 전송 프로토콜     |
    | 22  | SSH    | SSH,SFTP와 같은 프로토콜    |
    | 23  | Talnet | 암호화되지 않은 텍스트 통신 프로토콜 |
    | 25  | SMTP   | 이메일 전송 프로토콜          |
    | 53  | DNS    | IP주소와 도메인 이름 변환 프로토콜 |
    | 80  | HTTP   | 웹페이지전송 프로토콜          |
    | 123 | NTP    | 시간동기화 프로토콜           |
    | 443 | HTTPS  | 암호화된 웹페이지 전송 프로토콜    |
  - 1024-49141번 : registered port로 기관이나 기업들이 사용하는 포트번호 이다.
  - 49152 - 65535번 : dynamic port로 일반 사용자들이 자유롭게 사용할 수 있는 포트번호이다.

![image](https://github.com/user-attachments/assets/5cf623fc-06b0-4e53-9801-b48e420db278)

## 3.일련번호와 확인 응답번호 
- **일련번호** : 송신자가 수신자에게 보내려는 데이터가 몇 번째인지 알려주는 것이다.
- **확인응답번호** : 수신자가 몇 번째 데이터를 받았는지 송신자에게 알려주는 역할을 한다.

  > 예시<br>
  > 보내야할 총 데이터 크기 : 1500byte<br>
  > 패킷의 크기 : 500byte<br>
  > 패킷의 크기 : 한번에 보낼 수 있는 데이터의 최대 크기 
  > - 예시의 경우 총 3번을 송신해야한다. 
  > - 처음 보내는 데이터의 일련번호 : 1
  > - 두번째 보내는 데이터의 일련번호 : 501
  > - 세번재 보내는 데이터의 일련번호 : 1001
  1. 송신자는 500바이트의 데이터를 수신자에게 보낸다. 이때 3방향 핸드셰이크 연결과정에서 일련번호를 부여 받는다.(일려번호는 랜덤으로 생성)
  2. 수신자는 500바이트를 받았기 때문에 확인 응답번호는 받은데이터크기 + 일련번호가 된다.
  3. 송신자에게 확인응답번호를 전송하고 다음 패킷을 받는다.
  4. 2-3과정을 반복한다.
     ![image](https://github.com/user-attachments/assets/1bea1c58-8c6a-4a7b-aef1-e2d546102f12)

## 4. 윈도우 크기 
- **윈도우크기** : 송신자가 한번에 보낼 수 있는 데이터의 최대크기를 말한다.
- 수신자가 받을 수 있는 데이터의 양을 확인 후 데이터를 송신해야 한다. 
- 송신 할 수 있는 데이터의 크기 > 수신 할 수 있는 데이터의 크기 => 데이터 누수 발생
- TCP과정에서 서로의 윈도우 크기를 확인한다. 

![image](https://github.com/user-attachments/assets/5dbc06aa-ab54-402e-b85d-7a23829152c4)

## 5. 코드비트
- 코드 비트에는 데이터의 설정 값들을 저장한다. 
- 기본값은 0이며, 비트가 활성화 되면 1이 도니다. 

  | 항목   | 설명                      |
  |------|-------------------------|
  | TRUG | 긴급 처리 데이터가 있음           |
  | ACK  | 확인응답번호 사용               |
  | RSH  | TCP가 받은 데이터를 상위계층에 전달   |
  | RST  | 연결재설정                   |
  | SYN  | 연결을 초기화 하기 위해 순서번호를 동기환 |
  | FIN  | 데이터 송신 종료               |

  > TCP통신이 처음 연결할때의 코드 비트
    
  | TURG | ACK | RSH | RST | SYN | FIN |
  |------|-----|-----|-----|-----|-----| 
  | 0    | 1   | 0   | 0   | 1   | 0   |


# UDP의 구조 
- 데이터 송신의 효율성에 초점을 맞추는 통신프로토콜로 수신자 측의 오류를 검증 하지 않는다.
- 전송속도가 빠르다. 브로드캐스트에서 주로 사용된다. 

![image](https://github.com/user-attachments/assets/74d9c812-36f9-4155-8ae9-f30216ae870e)

## 1. UDP헤더의 구조 
- TCP헤더의 구조에 비해 축약된 정보만을 포함하고 있다. 
- 신뢰성을 보장하지는 못한다.

  ![image](https://github.com/user-attachments/assets/3bbfb506-2e81-4cdb-b176-68ba85b7ca95)
  
  | 항목      | 설명                          | 크기    |
  |---------|-----------------------------|-------|
  | 송신자포트번호 | 데이터를 보낼 때 사용되는 애플리케이션의 포트번호 | 16비트  |
  | 수신자포트번호 | 데이터를 받을 애플리케이션의 포트번호        | 16비트  |
  | 헤더길이    | UDP헤더와 데이터를 합한 총길이          | 16비트  |
  | 검사합     | 데이터의 무결성 검사(오류검사)용동         | 16비 트 |


# 전송계층에서 사용하는 로드밸런서 
- **로드밸런서(Load Balancer)** : 여러대의 서버를 두고 사용자가 한쪽으로 몰리는 것을 분산시켜주는 장치
- **스케일 아웃(Scale Out)** : 서버를 여러대로 늘리는 것을 말한다.
- **로드밸런싱(Load Balancing)** : 부하를 분산시키는 작업을 말한다. 

![image](https://github.com/user-attachments/assets/40c16d6b-f615-427c-a964-9ed548cf3644)

## 1. 로드밸런싱의 종류
- **라운드로빈(Round Robin)** : 각서버를 순회하면서 연결 처리를 하는 방법으로 가장 기본 적인 방법
- **가중 라운드로빈 (Weighted Round Robin)** : 각 서버별로 순회 연결을 하지만, 일부 서버는 큰 트래픽 전용 담당으로 배정하는 방법
- **랜덤(Random)** : 무작위로 분배되는 방법
- **해시(Hash)** : 특정클라이언트는 특정 서버만 처리하는 방법
- **포트(Port)** : 특정 포트로 연결을 요청하면, 특정 서버로 연결되게 하는 방식




































